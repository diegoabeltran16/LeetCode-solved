
# üìù Problem 21: Merge Two Sorted Lists

## **Problem Description**

Given the heads of two sorted linked lists, `list1` and `list2`, merge them into one sorted linked list. The list should be made by splicing together nodes of the first two lists without creating new nodes.

### **Merge Rules**

* Both input lists are sorted in non-decreasing order.
* The merged linked list should reuse existing nodes.
* Maintain the sorted order during merging.

---

## **Examples**

| Input                | Output          | Explanation                  |
| -------------------- | --------------- | ---------------------------- |
| `[1,2,4]`, `[1,3,4]` | `[1,1,2,3,4,4]` | Nodes merged in sorted order |
| `[]`, `[]`           | `[]`            | Both lists empty             |
| `[]`, `[0]`          | `[0]`           | One list empty               |

---

## **Constraints**

* Number of nodes in both lists: `[0, 50]`
* Node values: `-100 <= Node.val <= 100`
* Lists sorted in non-decreasing order.

---

## **Input**

* Heads of two singly-linked lists (`list1`, `list2`).

## **Output**

* Head of the merged sorted linked list.

---

## **Why is this problem important?**

* Fundamental problem for understanding linked list manipulation.
* Essential for mastering merge operations in algorithms like Merge Sort.
* Real-world analogy: **Merging sorted data streams efficiently**.

---

## üìä **Performance Comparison Summary**

| Language   | Runtime | Memory   | Approach                    | Conductor Type       |
| ---------- | ------- | -------- | --------------------------- | -------------------- |
| Python     | 1 ms    | 12.4 MB  | Dummy node, iterative merge | Cautious Conductor   |
| Go         | 0 ms    | 4.35 MB  | Dummy node, iterative merge | Nimble Conductor     |
| Rust       | 0 ms    | 2.1 MB   | Dummy node, iterative merge | Fearless Conductor   |
| Java       | 0 ms    | 42.6 MB  | Dummy node, iterative merge | Disciplined Conductor|
| JavaScript | 0 ms    | 58.3 MB  | Dummy node, iterative merge | Pragmatic Conductor  |
| C          | 0 ms    | 10.7 MB  | Dummy node, iterative merge | Deterministic Conductor |
| C++        | 0 ms    | 19.6 MB  | Dummy node, iterative merge | Classicist Conductor |
| C#         | 0 ms    | 43.0 MB  | Dummy node, iterative merge | Methodical Conductor |

---

## üí° **Analytical Summary**

‚úÖ **Fastest Runtime (0 ms)**: Go, Rust, Java, JS, C, C++, C#

‚úÖ **Best Memory Usage**: Rust < Go < C < C++

‚úÖ **Python**: Still valuable for readability and prototyping

---

## ‚öîÔ∏è **Approach Strengths & Trade-offs**

| Language   | Strength                            | Trade-off                         |
|------------|-------------------------------------|------------------------------------|
| Python     | Easy to read/write, ideal for test  | Slower, higher memory              |
| Go         | Efficient, low memory               | Less flexible types                |
| Rust       | High safety, low memory             | Steeper learning curve             |
| Java       | Enterprise ready, reliable          | Verbose, heavier runtime           |
| JS         | Web-native, quick prototyping       | Higher memory due to GC            |
| C          | Minimal overhead, raw performance   | Manual memory, error-prone         |
| C++        | Powerful STL, fast                  | Complex, potential memory issues   |
| C#         | Clear syntax, .NET integration      | More abstract, higher memory use   |

---

## üéì **Mentor Takeaways**

‚úÖ All implementations use **O(n + m)** time, **O(1)** space

‚úÖ Rust and Go are ideal for **systems-level performance**

‚úÖ Python/JavaScript shine for **teaching and demo**

‚úÖ Java and C# great for **enterprise structure**

‚úÖ C/C++ critical for **embedded and legacy systems**

---

## üõ§Ô∏è **Polyglot Merge Train Tale: United Lines of Dataville**

In the legendary **Dataville Central Yard**, eight great conductors gathered to prove their mettle:

- üêç **Python Express**, led by the *Cautious Conductor*: clear but careful, best for planning and prototyping.
- ü¶´ **Go Sprinter**, driven by the *Nimble Conductor*: direct, rapid, with minimal baggage.
- ‚öôÔ∏è **Rust Bullet**, operated by the *Fearless Conductor*: safe, exact, never wasteful.
- ‚òï **Java Express**, commanded by the *Disciplined Conductor*: systematic, always documented and structured.
- üåê **JavaScript Metro**, helmed by the *Pragmatic Conductor*: fast, browser-bound, ready to adapt.
- üß± **C Freightliner**, managed by the *Deterministic Conductor*: lean, mechanical, and brutally efficient.
- üß≠ **C++ Steamer**, run by the *Classicist Conductor*: master of legacy, elegance and optimization.
- üßë‚Äçüíº **C# Tramline**, supervised by the *Methodical Conductor*: structured, modern, and enterprise-ready.

> The Merge Track was conquered not by one‚Äîbut by **all**. For every need, there was a train. And for every train, a track was forged.

