using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

// Alias for throwing argument exceptions concisely
using AE = System.ArgumentException;

/// <summary>
/// LeetCode Problem 13: Roman to Integer
///
/// This class provides a method to convert a Roman numeral string
/// into its corresponding integer value.
///
/// The implementation handles standard Roman numeral notation,
/// including subtractive combinations (e.g., IV for 4, IX for 9, etc.).
/// </summary>
public class Solution
{
    /// <summary>
    /// Converts a Roman numeral string to its integer representation.
    /// </summary>
    /// <param name="s">A string containing the Roman numeral (e.g., "MCMXCIV").</param>
    /// <returns>The integer value corresponding to the Roman numeral.</returns>
    /// <exception cref="ArgumentException">Thrown when the computed value exceeds 3999.</exception>
    /// <example>
    /// Solution sol = new Solution();
    /// int result = sol.RomanToInt("MCMXCIV"); // result = 1994
    /// </example>
    public int RomanToInt(string s)
    {
        // Dictionary mapping Roman numeral characters to integer values
        Dictionary<char, int> rn = new Dictionary<char, int>
        {
            {'I', 1},
            {'V', 5},
            {'X', 10},
            {'L', 50},
            {'C', 100},
            {'D', 500},
            {'M', 1000}
        };

        int returnValue = 0;
        char prevDom = 'I';

        // Iterate from the end of the string to the beginning
        for (int i = s.Length - 1; i >= 0; i--)
        {
            if (rn[s[i]] < rn[prevDom])
            {
                // Subtractive combination detected, subtract current value
                returnValue -= rn[s[i]];
            }
            else
            {
                // Regular addition of numeral value
                returnValue += rn[s[i]];
            }

            // Update previous dominant numeral
            if (rn[s[i]] > rn[prevDom])
            {
                prevDom = s[i];
            }

            // Check for out-of-range values (problem constraint)
            if (returnValue > 3999)
            {
                throw new AE("Value out of range.");
            }
        }

        return returnValue;
    }
}
